enum ProposalStatus {
  PENDING
  ACTIVE
  CANCELLED
  QUEUED
  EXECUTED
}

type Delegate @entity {
  "A Delegate is any address that has been delegated with voting tokens by a token holder, id is the blockchain address of said delegate"
  id: ID!

  "Amount of XVS this user has staked"
  stakedXvsMantissa: BigInt!
  
  "Total amount of votes via delegation and staking"
  totalVotesMantissa: BigInt!

  "Accounts delegating to this voter"
  delegateCount: Int!

  "Accounts delegating to this voter"
  delegates: [Delegate!]!

  "Votes that a delegate has made in different proposals"
  votes: [Vote!]! @derivedFrom(field: "voter")

  "Proposals that the delegate has created"
  proposals: [Proposal!]! @derivedFrom(field: "proposer")
}

enum PROPOSAL_TYPE {
  NORMAL
  FASTRACK
  CRITICAL
}

type Proposal @entity {
  "Internal proposal ID, in this implementation it seems to be a autoincremental id"
  id: ID!

  "Delegate that proposed the change"
  proposer: Delegate!

  "Targets data for the change"
  targets: [Bytes!]

  "Values data for the change"
  values: [BigInt!]

  "Signature data for the change"
  signatures: [String!]

  "Call data for the change"
  calldatas: [Bytes!]

  "Block number from where the voting starts"
  startBlock: BigInt!

  "Block number from where the voting ends"
  endBlock: BigInt!

  "String description of the change"
  description: String!

  "Status of the proposal"
  status: ProposalStatus!

  "Once the proposal is queued for execution it will have an ETA of the execution"
  executionETA: BigInt

  "Votes associated to this proposal"
  votes: [Vote!]! @derivedFrom(field: "proposal")

  "Type of Proposal can be normal fast track or critical"
  type: PROPOSAL_TYPE!
}

enum SUPPORT {
  FOR
  AGAINST
  ABSTAIN
}

type Vote @entity {
  "Delegate ID + Proposal ID"
  id: ID!

  "Whether the vote is in favour or against the proposal"
  support: SUPPORT!

  "Amount of votes in favour or against expressed in the smallest unit of the XVS Token"
  votes: BigInt!

  "Delegate that emitted the vote"
  voter: Delegate!

  "Proposal that is being voted on"
  proposal: Proposal!
}

type Governance @entity {
  "Unique entity used to keep track of common aggregated data"
  id: ID!

  "Number of proposals created"
  proposals: BigInt!

  "Total number of accounts delegates that can participate in governance by voting or creating proposals"
  totalDelegates: BigInt!
  
  "Total number of accounts participating in governance as delegates or by delegating"
  totalVoters: BigInt!

  "Total number of votes delegated expressed in the smallest unit of XVS"
  totalVotesMantissa: BigInt!

  "Number of proposals currently queued for execution"
  proposalsQueued: BigInt!
  
  "The number of votes required to reach quorum"
  quorumVotesMantissa: BigInt!
  
  "Active brains of Governor"
  implementation: Bytes!
  
  "Pending administrator for this contract"
  pendingAdmin: Bytes

  "Administrator for this contract"
  admin: Bytes!
  
  "A privileged role that can cancel any proposal"
  guardian: Bytes!

  "The maximum number of actions that can be included in a proposal"
  proposalMaxOperations: BigInt!
}

type GovernanceRoute @entity {
  "Index of the governance route"
  id: ID!
  "Governor implementation the route belongs to"
  governor: Bytes!
  "Address of timelock contract for route"
  timelock: Bytes!
  "Que execution delay in blocks"
  queueDelay: BigInt!
  "The delay before voting on a proposal may take place, once proposed, in blocks"
  votingDelay: BigInt!
  "The duration of voting on a proposal, in blocks"
  votingPeriod: BigInt!
  "The number of votes required in order for a voter to become a proposer"
  proposalThreshold: BigInt!
}

enum PermissionStatus {
  GRANTED,
  REVOKED
}

type Permission @entity {
  "ID generated for each Permission"
  id: ID!

  "Indicates if the permission was either GRANTED or REVOKED"
  type: PermissionStatus!

  "The target account of the event"
  account: Bytes!

  "The target contract for the permission event"
  contractAddress: Bytes!

  "The function name for the permission event"
  functionSig: String!
}
