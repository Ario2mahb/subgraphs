diff --git a/node_modules/@venusprotocol/venus-protocol/contracts/Comptroller/ComptrollerInterface.sol b/node_modules/@venusprotocol/venus-protocol/contracts/Comptroller/ComptrollerInterface.sol
index a6c8838..2d54e80 100644
--- a/node_modules/@venusprotocol/venus-protocol/contracts/Comptroller/ComptrollerInterface.sol
+++ b/node_modules/@venusprotocol/venus-protocol/contracts/Comptroller/ComptrollerInterface.sol
@@ -1,6 +1,6 @@
 pragma solidity ^0.5.16;
 
-import "../Tokens/VTokens/VToken.sol";
+import { CorePoolVToken as VToken } from "../Tokens/VTokens/VToken.sol";
 import "../Oracle/PriceOracle.sol";
 import "../Tokens/VAI/VAIControllerInterface.sol";
 
diff --git a/node_modules/@venusprotocol/venus-protocol/contracts/Comptroller/ComptrollerLensInterface.sol b/node_modules/@venusprotocol/venus-protocol/contracts/Comptroller/ComptrollerLensInterface.sol
index 2f56b52..fcd8940 100644
--- a/node_modules/@venusprotocol/venus-protocol/contracts/Comptroller/ComptrollerLensInterface.sol
+++ b/node_modules/@venusprotocol/venus-protocol/contracts/Comptroller/ComptrollerLensInterface.sol
@@ -1,7 +1,7 @@
 pragma solidity ^0.5.16;
 pragma experimental ABIEncoderV2;
 
-import "../Tokens/VTokens/VToken.sol";
+import { CorePoolVToken as VToken } from "../Tokens/VTokens/VToken.sol";
 
 interface ComptrollerLensInterface {
     function liquidateCalculateSeizeTokens(
diff --git a/node_modules/@venusprotocol/venus-protocol/contracts/Comptroller/ComptrollerStorage.sol b/node_modules/@venusprotocol/venus-protocol/contracts/Comptroller/ComptrollerStorage.sol
index f662961..000d430 100644
--- a/node_modules/@venusprotocol/venus-protocol/contracts/Comptroller/ComptrollerStorage.sol
+++ b/node_modules/@venusprotocol/venus-protocol/contracts/Comptroller/ComptrollerStorage.sol
@@ -2,7 +2,7 @@
 
 pragma solidity ^0.5.16;
 
-import { VToken } from "../Tokens/VTokens/VToken.sol";
+import { CorePoolVToken as VToken } from  "../Tokens/VTokens/VToken.sol";
 import { PriceOracle } from "../Oracle/PriceOracle.sol";
 import { VAIControllerInterface } from "../Tokens/VAI/VAIControllerInterface.sol";
 import { ComptrollerLensInterface } from "./ComptrollerLensInterface.sol";
diff --git a/node_modules/@venusprotocol/venus-protocol/contracts/Comptroller/Diamond/facets/FacetBase.sol b/node_modules/@venusprotocol/venus-protocol/contracts/Comptroller/Diamond/facets/FacetBase.sol
index 0897c1e..d563c78 100644
--- a/node_modules/@venusprotocol/venus-protocol/contracts/Comptroller/Diamond/facets/FacetBase.sol
+++ b/node_modules/@venusprotocol/venus-protocol/contracts/Comptroller/Diamond/facets/FacetBase.sol
@@ -2,7 +2,7 @@
 
 pragma solidity 0.5.16;
 
-import { VToken, ComptrollerErrorReporter, ExponentialNoError } from "../../../Tokens/VTokens/VToken.sol";
+import { CorePoolVToken as VToken, ComptrollerErrorReporter, ExponentialNoError } from "../../../Tokens/VTokens/VToken.sol";
 import { IVAIVault } from "../../../Comptroller/ComptrollerInterface.sol";
 import { ComptrollerV15Storage } from "../../../Comptroller/ComptrollerStorage.sol";
 import { IAccessControlManagerV5 } from "@venusprotocol/governance-contracts/contracts/Governance/IAccessControlManagerV5.sol";
diff --git a/node_modules/@venusprotocol/venus-protocol/contracts/Comptroller/Diamond/facets/MarketFacet.sol b/node_modules/@venusprotocol/venus-protocol/contracts/Comptroller/Diamond/facets/MarketFacet.sol
index 654a351..9c670f4 100644
--- a/node_modules/@venusprotocol/venus-protocol/contracts/Comptroller/Diamond/facets/MarketFacet.sol
+++ b/node_modules/@venusprotocol/venus-protocol/contracts/Comptroller/Diamond/facets/MarketFacet.sol
@@ -4,7 +4,7 @@ pragma solidity 0.5.16;
 
 import { IMarketFacet } from "../interfaces/IMarketFacet.sol";
 import { FacetBase } from "./FacetBase.sol";
-import { VToken } from "../../../Tokens/VTokens/VToken.sol";
+import { CorePoolVToken as VToken } from  "../../../Tokens/VTokens/VToken.sol";
 
 /**
  * @title MarketFacet
diff --git a/node_modules/@venusprotocol/venus-protocol/contracts/Comptroller/Diamond/facets/PolicyFacet.sol b/node_modules/@venusprotocol/venus-protocol/contracts/Comptroller/Diamond/facets/PolicyFacet.sol
index 9702f65..4cc47dd 100644
--- a/node_modules/@venusprotocol/venus-protocol/contracts/Comptroller/Diamond/facets/PolicyFacet.sol
+++ b/node_modules/@venusprotocol/venus-protocol/contracts/Comptroller/Diamond/facets/PolicyFacet.sol
@@ -2,7 +2,7 @@
 
 pragma solidity 0.5.16;
 
-import { VToken } from "../../../Tokens/VTokens/VToken.sol";
+import { CorePoolVToken as VToken } from  "../../../Tokens/VTokens/VToken.sol";
 import { IPolicyFacet } from "../interfaces/IPolicyFacet.sol";
 
 import { XVSRewardsHelper } from "./XVSRewardsHelper.sol";
diff --git a/node_modules/@venusprotocol/venus-protocol/contracts/Comptroller/Diamond/facets/RewardFacet.sol b/node_modules/@venusprotocol/venus-protocol/contracts/Comptroller/Diamond/facets/RewardFacet.sol
index d84f6e4..fb63e60 100644
--- a/node_modules/@venusprotocol/venus-protocol/contracts/Comptroller/Diamond/facets/RewardFacet.sol
+++ b/node_modules/@venusprotocol/venus-protocol/contracts/Comptroller/Diamond/facets/RewardFacet.sol
@@ -2,7 +2,7 @@
 
 pragma solidity 0.5.16;
 
-import { VToken } from "../../../Tokens/VTokens/VToken.sol";
+import { CorePoolVToken as VToken } from  "../../../Tokens/VTokens/VToken.sol";
 import { IRewardFacet } from "../interfaces/IRewardFacet.sol";
 import { XVSRewardsHelper } from "./XVSRewardsHelper.sol";
 import { SafeBEP20, IBEP20 } from "../../../Utils/SafeBEP20.sol";
diff --git a/node_modules/@venusprotocol/venus-protocol/contracts/Comptroller/Diamond/facets/SetterFacet.sol b/node_modules/@venusprotocol/venus-protocol/contracts/Comptroller/Diamond/facets/SetterFacet.sol
index 692b39c..b411bc7 100644
--- a/node_modules/@venusprotocol/venus-protocol/contracts/Comptroller/Diamond/facets/SetterFacet.sol
+++ b/node_modules/@venusprotocol/venus-protocol/contracts/Comptroller/Diamond/facets/SetterFacet.sol
@@ -2,7 +2,7 @@
 
 pragma solidity 0.5.16;
 
-import { VToken } from "../../../Tokens/VTokens/VToken.sol";
+import { CorePoolVToken as VToken } from  "../../../Tokens/VTokens/VToken.sol";
 import { ISetterFacet } from "../interfaces/ISetterFacet.sol";
 import { PriceOracle } from "../../../Oracle/PriceOracle.sol";
 import { ComptrollerLensInterface } from "../../ComptrollerLensInterface.sol";
diff --git a/node_modules/@venusprotocol/venus-protocol/contracts/Comptroller/Diamond/facets/XVSRewardsHelper.sol b/node_modules/@venusprotocol/venus-protocol/contracts/Comptroller/Diamond/facets/XVSRewardsHelper.sol
index 46bb333..0a9351e 100644
--- a/node_modules/@venusprotocol/venus-protocol/contracts/Comptroller/Diamond/facets/XVSRewardsHelper.sol
+++ b/node_modules/@venusprotocol/venus-protocol/contracts/Comptroller/Diamond/facets/XVSRewardsHelper.sol
@@ -2,7 +2,7 @@
 
 pragma solidity 0.5.16;
 
-import { VToken } from "../../../Tokens/VTokens/VToken.sol";
+import { CorePoolVToken as VToken } from  "../../../Tokens/VTokens/VToken.sol";
 import { FacetBase } from "./FacetBase.sol";
 
 /**
diff --git a/node_modules/@venusprotocol/venus-protocol/contracts/Comptroller/Diamond/interfaces/IMarketFacet.sol b/node_modules/@venusprotocol/venus-protocol/contracts/Comptroller/Diamond/interfaces/IMarketFacet.sol
index 684d76f..b585587 100644
--- a/node_modules/@venusprotocol/venus-protocol/contracts/Comptroller/Diamond/interfaces/IMarketFacet.sol
+++ b/node_modules/@venusprotocol/venus-protocol/contracts/Comptroller/Diamond/interfaces/IMarketFacet.sol
@@ -2,7 +2,7 @@
 
 pragma solidity 0.5.16;
 
-import { VToken } from "../../../Tokens/VTokens/VToken.sol";
+import { CorePoolVToken as VToken } from  "../../../Tokens/VTokens/VToken.sol";
 
 interface IMarketFacet {
     function isComptroller() external pure returns (bool);
diff --git a/node_modules/@venusprotocol/venus-protocol/contracts/Comptroller/Diamond/interfaces/IPolicyFacet.sol b/node_modules/@venusprotocol/venus-protocol/contracts/Comptroller/Diamond/interfaces/IPolicyFacet.sol
index 3eac49c..faf85a5 100644
--- a/node_modules/@venusprotocol/venus-protocol/contracts/Comptroller/Diamond/interfaces/IPolicyFacet.sol
+++ b/node_modules/@venusprotocol/venus-protocol/contracts/Comptroller/Diamond/interfaces/IPolicyFacet.sol
@@ -2,7 +2,7 @@
 
 pragma solidity 0.5.16;
 
-import { VToken } from "../../../Tokens/VTokens/VToken.sol";
+import { CorePoolVToken as VToken } from "../../../Tokens/VTokens/VToken.sol";
 
 interface IPolicyFacet {
     function mintAllowed(address vToken, address minter, uint256 mintAmount) external returns (uint256);
diff --git a/node_modules/@venusprotocol/venus-protocol/contracts/Comptroller/Diamond/interfaces/IRewardFacet.sol b/node_modules/@venusprotocol/venus-protocol/contracts/Comptroller/Diamond/interfaces/IRewardFacet.sol
index 6b5eb75..94badd6 100644
--- a/node_modules/@venusprotocol/venus-protocol/contracts/Comptroller/Diamond/interfaces/IRewardFacet.sol
+++ b/node_modules/@venusprotocol/venus-protocol/contracts/Comptroller/Diamond/interfaces/IRewardFacet.sol
@@ -2,7 +2,7 @@
 
 pragma solidity 0.5.16;
 
-import { VToken } from "../../../Tokens/VTokens/VToken.sol";
+import { CorePoolVToken as VToken } from "../../../Tokens/VTokens/VToken.sol";
 import { ComptrollerTypes } from "../../ComptrollerStorage.sol";
 
 interface IRewardFacet {
diff --git a/node_modules/@venusprotocol/venus-protocol/contracts/Comptroller/Diamond/interfaces/ISetterFacet.sol b/node_modules/@venusprotocol/venus-protocol/contracts/Comptroller/Diamond/interfaces/ISetterFacet.sol
index 6464f5c..a3d1a9d 100644
--- a/node_modules/@venusprotocol/venus-protocol/contracts/Comptroller/Diamond/interfaces/ISetterFacet.sol
+++ b/node_modules/@venusprotocol/venus-protocol/contracts/Comptroller/Diamond/interfaces/ISetterFacet.sol
@@ -3,7 +3,7 @@
 pragma solidity 0.5.16;
 
 import { PriceOracle } from "../../../Oracle/PriceOracle.sol";
-import { VToken } from "../../../Tokens/VTokens/VToken.sol";
+import { CorePoolVToken as VToken } from "../../../Tokens/VTokens/VToken.sol";
 import { ComptrollerTypes } from "../../ComptrollerStorage.sol";
 import { VAIControllerInterface } from "../../../Tokens/VAI/VAIControllerInterface.sol";
 import { ComptrollerLensInterface } from "../../../Comptroller/ComptrollerLensInterface.sol";
diff --git a/node_modules/@venusprotocol/venus-protocol/contracts/Lens/ComptrollerLens.sol b/node_modules/@venusprotocol/venus-protocol/contracts/Lens/ComptrollerLens.sol
index 47e18e3..2394a23 100644
--- a/node_modules/@venusprotocol/venus-protocol/contracts/Lens/ComptrollerLens.sol
+++ b/node_modules/@venusprotocol/venus-protocol/contracts/Lens/ComptrollerLens.sol
@@ -2,7 +2,7 @@ pragma solidity ^0.5.16;
 pragma experimental ABIEncoderV2;
 
 import "../Tokens/VTokens/VBep20.sol";
-import { VToken } from "../Tokens/VTokens/VToken.sol";
+import { CorePoolVToken as VToken } from "../Tokens/VTokens/VToken.sol";
 import { ExponentialNoError } from "../Utils/ExponentialNoError.sol";
 import "../Tokens/EIP20Interface.sol";
 import "../Oracle/PriceOracle.sol";
diff --git a/node_modules/@venusprotocol/venus-protocol/contracts/Lens/SnapshotLens.sol b/node_modules/@venusprotocol/venus-protocol/contracts/Lens/SnapshotLens.sol
index 11b56be..04303bd 100644
--- a/node_modules/@venusprotocol/venus-protocol/contracts/Lens/SnapshotLens.sol
+++ b/node_modules/@venusprotocol/venus-protocol/contracts/Lens/SnapshotLens.sol
@@ -1,7 +1,7 @@
 pragma solidity ^0.5.16;
 pragma experimental ABIEncoderV2;
 
-import { VToken } from "../Tokens/VTokens/VToken.sol";
+import { CorePoolVToken as VToken } from "../Tokens/VTokens/VToken.sol";
 import { ExponentialNoError } from "../Utils/ExponentialNoError.sol";
 import "../Utils/SafeMath.sol";
 import "../Comptroller/ComptrollerInterface.sol";
diff --git a/node_modules/@venusprotocol/venus-protocol/contracts/Lens/VenusLens.sol b/node_modules/@venusprotocol/venus-protocol/contracts/Lens/VenusLens.sol
index a2448a4..805e5fa 100644
--- a/node_modules/@venusprotocol/venus-protocol/contracts/Lens/VenusLens.sol
+++ b/node_modules/@venusprotocol/venus-protocol/contracts/Lens/VenusLens.sol
@@ -2,7 +2,7 @@ pragma solidity ^0.5.16;
 pragma experimental ABIEncoderV2;
 
 import "../Tokens/VTokens/VBep20.sol";
-import "../Tokens/VTokens/VToken.sol";
+import { CorePoolVToken as VToken } from "../Tokens/VTokens/VToken.sol";
 import "../Oracle/PriceOracle.sol";
 import "../Tokens/EIP20Interface.sol";
 import "../Tokens/XVS/XVS.sol";
diff --git a/node_modules/@venusprotocol/venus-protocol/contracts/Oracle/PriceOracle.sol b/node_modules/@venusprotocol/venus-protocol/contracts/Oracle/PriceOracle.sol
index 15f44c1..7b4f135 100644
--- a/node_modules/@venusprotocol/venus-protocol/contracts/Oracle/PriceOracle.sol
+++ b/node_modules/@venusprotocol/venus-protocol/contracts/Oracle/PriceOracle.sol
@@ -1,16 +1,16 @@
 pragma solidity ^0.5.16;
 
-import "../Tokens/VTokens/VToken.sol";
+import { CorePoolVToken as VToken } from '../Tokens/VTokens/VToken.sol';
 
 contract PriceOracle {
-    /// @notice Indicator that this is a PriceOracle contract (for inspection)
-    bool public constant isPriceOracle = true;
+  /// @notice Indicator that this is a PriceOracle contract (for inspection)
+  bool public constant isPriceOracle = true;
 
-    /**
-     * @notice Get the underlying price of a vToken asset
-     * @param vToken The vToken to get the underlying price of
-     * @return The underlying asset price mantissa (scaled by 1e18).
-     *  Zero means the price is unavailable.
-     */
-    function getUnderlyingPrice(VToken vToken) external view returns (uint);
+  /**
+   * @notice Get the underlying price of a vToken asset
+   * @param vToken The vToken to get the underlying price of
+   * @return The underlying asset price mantissa (scaled by 1e18).
+   *  Zero means the price is unavailable.
+   */
+  function getUnderlyingPrice(VToken vToken) external view returns (uint);
 }
diff --git a/node_modules/@venusprotocol/venus-protocol/contracts/Tokens/VAI/VAIController.sol b/node_modules/@venusprotocol/venus-protocol/contracts/Tokens/VAI/VAIController.sol
index 508a07a..c818fdd 100644
--- a/node_modules/@venusprotocol/venus-protocol/contracts/Tokens/VAI/VAIController.sol
+++ b/node_modules/@venusprotocol/venus-protocol/contracts/Tokens/VAI/VAIController.sol
@@ -6,7 +6,7 @@ import { VAIControllerErrorReporter } from "../../Utils/ErrorReporter.sol";
 import { Exponential } from "../../Utils/Exponential.sol";
 import { ComptrollerInterface } from "../../Comptroller/ComptrollerInterface.sol";
 import { IAccessControlManagerV5 } from "@venusprotocol/governance-contracts/contracts/Governance/IAccessControlManagerV5.sol";
-import { VToken, EIP20Interface } from "../VTokens/VToken.sol";
+import { CorePoolVToken as VToken, EIP20Interface } from "../VTokens/VToken.sol";
 import { VAIUnitroller, VAIControllerStorageG4 } from "./VAIUnitroller.sol";
 import { VAI } from "./VAI.sol";
 import { IPrime } from "../Prime/IPrime.sol";
diff --git a/node_modules/@venusprotocol/venus-protocol/contracts/Tokens/VTokens/VBep20.sol b/node_modules/@venusprotocol/venus-protocol/contracts/Tokens/VTokens/VBep20.sol
index e788777..31a188a 100644
--- a/node_modules/@venusprotocol/venus-protocol/contracts/Tokens/VTokens/VBep20.sol
+++ b/node_modules/@venusprotocol/venus-protocol/contracts/Tokens/VTokens/VBep20.sol
@@ -1,6 +1,6 @@
 pragma solidity ^0.5.16;
 
-import { VToken, VBep20Interface, ComptrollerInterface, InterestRateModel, VTokenInterface } from "./VToken.sol";
+import { CorePoolVToken as VToken, VBep20Interface, ComptrollerInterface, InterestRateModel, VTokenInterface } from "./VToken.sol";
 import { EIP20Interface } from "../EIP20Interface.sol";
 import { EIP20NonStandardInterface } from "../EIP20NonStandardInterface.sol";
 
diff --git a/node_modules/@venusprotocol/venus-protocol/contracts/Tokens/VTokens/VToken.sol b/node_modules/@venusprotocol/venus-protocol/contracts/Tokens/VTokens/VToken.sol
index 7786270..8334f51 100644
--- a/node_modules/@venusprotocol/venus-protocol/contracts/Tokens/VTokens/VToken.sol
+++ b/node_modules/@venusprotocol/venus-protocol/contracts/Tokens/VTokens/VToken.sol
@@ -14,7 +14,7 @@ import { IAccessControlManagerV5 } from "@venusprotocol/governance-contracts/con
  * @notice Abstract base for vTokens
  * @author Venus
  */
-contract VToken is VTokenInterface, Exponential, TokenErrorReporter {
+contract CorePoolVToken is VTokenInterface, Exponential, TokenErrorReporter {
     struct MintLocalVars {
         MathError mathErr;
         uint exchangeRateMantissa;
diff --git a/node_modules/@venusprotocol/venus-protocol/contracts/test/MockVBNB.sol b/node_modules/@venusprotocol/venus-protocol/contracts/test/MockVBNB.sol
index 3d98cda..11c3a84 100644
--- a/node_modules/@venusprotocol/venus-protocol/contracts/test/MockVBNB.sol
+++ b/node_modules/@venusprotocol/venus-protocol/contracts/test/MockVBNB.sol
@@ -1,6 +1,6 @@
 pragma solidity ^0.5.16;
 
-import "../Tokens/VTokens/VToken.sol";
+import { CorePoolVToken as VToken } from '../Tokens/VTokens/VToken.sol';
 
 /**
  * @title Venus's vBNB Contract
@@ -8,364 +8,379 @@ import "../Tokens/VTokens/VToken.sol";
  * @author Venus
  */
 contract MockVBNB is VToken {
-    /**
-     * @notice Construct a new vBNB money market
-     * @param comptroller_ The address of the Comptroller
-     * @param interestRateModel_ The address of the interest rate model
-     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18
-     * @param name_ BEP-20 name of this token
-     * @param symbol_ BEP-20 symbol of this token
-     * @param decimals_ BEP-20 decimal precision of this token
-     * @param admin_ Address of the administrator of this token
-     */
-    constructor(
-        ComptrollerInterface comptroller_,
-        InterestRateModel interestRateModel_,
-        uint initialExchangeRateMantissa_,
-        string memory name_,
-        string memory symbol_,
-        uint8 decimals_,
-        address payable admin_
-    ) public {
-        // Creator of the contract is admin during initialization
-        admin = msg.sender;
-
-        initialize(comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_);
-
-        // Set the proper admin now that initialization is done
-        admin = admin_;
-    }
-
-    /**
-     * @notice Send BNB to VBNB to mint
-     */
-    function() external payable {
-        (uint err, ) = mintInternal(msg.value);
-        requireNoError(err, "mint failed");
+  /**
+   * @notice Construct a new vBNB money market
+   * @param comptroller_ The address of the Comptroller
+   * @param interestRateModel_ The address of the interest rate model
+   * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18
+   * @param name_ BEP-20 name of this token
+   * @param symbol_ BEP-20 symbol of this token
+   * @param decimals_ BEP-20 decimal precision of this token
+   * @param admin_ Address of the administrator of this token
+   */
+  constructor(
+    ComptrollerInterface comptroller_,
+    InterestRateModel interestRateModel_,
+    uint initialExchangeRateMantissa_,
+    string memory name_,
+    string memory symbol_,
+    uint8 decimals_,
+    address payable admin_
+  ) public {
+    // Creator of the contract is admin during initialization
+    admin = msg.sender;
+
+    initialize(
+      comptroller_,
+      interestRateModel_,
+      initialExchangeRateMantissa_,
+      name_,
+      symbol_,
+      decimals_
+    );
+
+    // Set the proper admin now that initialization is done
+    admin = admin_;
+  }
+
+  /**
+   * @notice Send BNB to VBNB to mint
+   */
+  function() external payable {
+    (uint err, ) = mintInternal(msg.value);
+    requireNoError(err, 'mint failed');
+  }
+
+  /*** User Interface ***/
+
+  /**
+   * @notice Sender supplies assets into the market and receives vTokens in exchange
+   * @dev Reverts upon any failure
+   */
+  // @custom:event Emits Transfer event
+  // @custom:event Emits Mint event
+  function mint() external payable {
+    (uint err, ) = mintInternal(msg.value);
+    requireNoError(err, 'mint failed');
+  }
+
+  /**
+   * @notice Sender redeems vTokens in exchange for the underlying asset
+   * @dev Accrues interest whether or not the operation succeeds, unless reverted
+   * @param redeemTokens The number of vTokens to redeem into underlying
+   * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).
+   */
+  // @custom:event Emits Redeem event on success
+  // @custom:event Emits Transfer event on success
+  // @custom:event Emits RedeemFee when fee is charged by the treasury
+  function redeem(uint redeemTokens) external returns (uint) {
+    return redeemInternal(redeemTokens);
+  }
+
+  /**
+   * @notice Sender redeems vTokens in exchange for a specified amount of underlying asset
+   * @dev Accrues interest whether or not the operation succeeds, unless reverted
+   * @param redeemAmount The amount of underlying to redeem
+   * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).
+   */
+  // @custom:event Emits Redeem event on success
+  // @custom:event Emits Transfer event on success
+  // @custom:event Emits RedeemFee when fee is charged by the treasury
+  function redeemUnderlying(uint redeemAmount) external returns (uint) {
+    return redeemUnderlyingInternal(redeemAmount);
+  }
+
+  /**
+   * @notice Sender borrows assets from the protocol to their own address
+   * @param borrowAmount The amount of the underlying asset to borrow
+   * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).
+   */
+  // @custom:event Emits Borrow event on success
+  function borrow(uint borrowAmount) external returns (uint) {
+    return borrowInternal(msg.sender, msg.sender, borrowAmount);
+  }
+
+  /**
+   * @notice Sender repays their own borrow
+   * @dev Reverts upon any failure
+   */
+  // @custom:event Emits RepayBorrow event on success
+  function repayBorrow() external payable {
+    (uint err, ) = repayBorrowInternal(msg.value);
+    requireNoError(err, 'repayBorrow failed');
+  }
+
+  /**
+   * @notice Sender repays a borrow belonging to borrower
+   * @dev Reverts upon any failure
+   * @param borrower The account with the debt being payed off
+   */
+  // @custom:event Emits RepayBorrow event on success
+  function repayBorrowBehalf(address borrower) external payable {
+    (uint err, ) = repayBorrowBehalfInternal(borrower, msg.value);
+    requireNoError(err, 'repayBorrowBehalf failed');
+  }
+
+  /**
+   * @notice The sender liquidates the borrowers collateral.
+   *  The collateral seized is transferred to the liquidator.
+   * @dev Reverts upon any failure
+   * @param borrower The borrower of this vToken to be liquidated
+   * @param vTokenCollateral The market in which to seize collateral from the borrower
+   */
+  // @custom:event Emit LiquidateBorrow event on success
+  function liquidateBorrow(address borrower, VToken vTokenCollateral) external payable {
+    (uint err, ) = liquidateBorrowInternal(borrower, msg.value, vTokenCollateral);
+    requireNoError(err, 'liquidateBorrow failed');
+  }
+
+  function setTotalReserves(uint totalReserves_) external payable {
+    totalReserves = totalReserves_;
+  }
+
+  /*** Safe Token ***/
+
+  /**
+   * @notice Perform the actual transfer in, which is a no-op
+   * @param from Address sending the BNB
+   * @param amount Amount of BNB being sent
+   * @return The actual amount of BNB transferred
+   */
+  function doTransferIn(address from, uint amount) internal returns (uint) {
+    // Sanity checks
+    require(msg.sender == from, 'sender mismatch');
+    require(msg.value == amount, 'value mismatch');
+    return amount;
+  }
+
+  function doTransferOut(address payable to, uint amount) internal {
+    /* Send the BNB, with minimal gas and revert on failure */
+    to.transfer(amount);
+  }
+
+  /**
+   * @notice Gets balance of this contract in terms of BNB, before this message
+   * @dev This excludes the value of the current message, if any
+   * @return The quantity of BNB owned by this contract
+   */
+  function getCashPrior() internal view returns (uint) {
+    (MathError err, uint startingBalance) = subUInt(address(this).balance, msg.value);
+    require(err == MathError.NO_ERROR, 'cash prior math error');
+    return startingBalance;
+  }
+
+  function requireNoError(uint errCode, string memory message) internal pure {
+    if (errCode == uint(Error.NO_ERROR)) {
+      return;
     }
 
-    /*** User Interface ***/
+    bytes memory fullMessage = new bytes(bytes(message).length + 5);
+    uint i;
 
-    /**
-     * @notice Sender supplies assets into the market and receives vTokens in exchange
-     * @dev Reverts upon any failure
-     */
-    // @custom:event Emits Transfer event
-    // @custom:event Emits Mint event
-    function mint() external payable {
-        (uint err, ) = mintInternal(msg.value);
-        requireNoError(err, "mint failed");
+    for (i = 0; i < bytes(message).length; i++) {
+      fullMessage[i] = bytes(message)[i];
     }
 
-    /**
-     * @notice Sender redeems vTokens in exchange for the underlying asset
-     * @dev Accrues interest whether or not the operation succeeds, unless reverted
-     * @param redeemTokens The number of vTokens to redeem into underlying
-     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).
-     */
-    // @custom:event Emits Redeem event on success
-    // @custom:event Emits Transfer event on success
-    // @custom:event Emits RedeemFee when fee is charged by the treasury
-    function redeem(uint redeemTokens) external returns (uint) {
-        return redeemInternal(redeemTokens);
+    fullMessage[i + 0] = bytes1(uint8(32));
+    fullMessage[i + 1] = bytes1(uint8(40));
+    fullMessage[i + 2] = bytes1(uint8(48 + (errCode / 10)));
+    fullMessage[i + 3] = bytes1(uint8(48 + (errCode % 10)));
+    fullMessage[i + 4] = bytes1(uint8(41));
+
+    require(errCode == uint(Error.NO_ERROR), string(fullMessage));
+  }
+
+  /**
+   * @dev Function to simply retrieve block number
+   *  This exists mainly for inheriting test contracts to stub this result.
+   */
+  function getBlockNumber() internal view returns (uint) {
+    return block.number;
+  }
+
+  /**
+   * @notice Reduces reserves by transferring to admin
+   * @dev Requires fresh interest accrual
+   * @param reduceAmount Amount of reduction to reserves
+   * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).
+   */
+  function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {
+    // totalReserves - reduceAmount
+    uint totalReservesNew;
+
+    // Check caller is admin
+    if (msg.sender != admin) {
+      return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);
     }
 
-    /**
-     * @notice Sender redeems vTokens in exchange for a specified amount of underlying asset
-     * @dev Accrues interest whether or not the operation succeeds, unless reverted
-     * @param redeemAmount The amount of underlying to redeem
-     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).
-     */
-    // @custom:event Emits Redeem event on success
-    // @custom:event Emits Transfer event on success
-    // @custom:event Emits RedeemFee when fee is charged by the treasury
-    function redeemUnderlying(uint redeemAmount) external returns (uint) {
-        return redeemUnderlyingInternal(redeemAmount);
+    // We fail gracefully unless market's block number equals current block number
+    if (accrualBlockNumber != getBlockNumber()) {
+      return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);
     }
 
-    /**
-     * @notice Sender borrows assets from the protocol to their own address
-     * @param borrowAmount The amount of the underlying asset to borrow
-     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).
-     */
-    // @custom:event Emits Borrow event on success
-    function borrow(uint borrowAmount) external returns (uint) {
-        return borrowInternal(msg.sender, msg.sender, borrowAmount);
+    // Fail gracefully if protocol has insufficient underlying cash
+    if (getCashPrior() < reduceAmount) {
+      return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);
     }
 
-    /**
-     * @notice Sender repays their own borrow
-     * @dev Reverts upon any failure
-     */
-    // @custom:event Emits RepayBorrow event on success
-    function repayBorrow() external payable {
-        (uint err, ) = repayBorrowInternal(msg.value);
-        requireNoError(err, "repayBorrow failed");
+    // Check reduceAmount ≤ reserves[n] (totalReserves)
+    if (reduceAmount > totalReserves) {
+      return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);
     }
 
-    /**
-     * @notice Sender repays a borrow belonging to borrower
-     * @dev Reverts upon any failure
-     * @param borrower The account with the debt being payed off
-     */
-    // @custom:event Emits RepayBorrow event on success
-    function repayBorrowBehalf(address borrower) external payable {
-        (uint err, ) = repayBorrowBehalfInternal(borrower, msg.value);
-        requireNoError(err, "repayBorrowBehalf failed");
-    }
+    /////////////////////////
+    // EFFECTS & INTERACTIONS
+    // (No safe failures beyond this point)
 
-    /**
-     * @notice The sender liquidates the borrowers collateral.
-     *  The collateral seized is transferred to the liquidator.
-     * @dev Reverts upon any failure
-     * @param borrower The borrower of this vToken to be liquidated
-     * @param vTokenCollateral The market in which to seize collateral from the borrower
-     */
-    // @custom:event Emit LiquidateBorrow event on success
-    function liquidateBorrow(address borrower, VToken vTokenCollateral) external payable {
-        (uint err, ) = liquidateBorrowInternal(borrower, msg.value, vTokenCollateral);
-        requireNoError(err, "liquidateBorrow failed");
-    }
+    totalReservesNew = totalReserves - reduceAmount;
 
-    function setTotalReserves(uint totalReserves_) external payable {
-        totalReserves = totalReserves_;
-    }
+    // Store reserves[n+1] = reserves[n] - reduceAmount
+    totalReserves = totalReservesNew;
 
-    /*** Safe Token ***/
+    // // doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.
+    doTransferOut(admin, reduceAmount);
 
-    /**
-     * @notice Perform the actual transfer in, which is a no-op
-     * @param from Address sending the BNB
-     * @param amount Amount of BNB being sent
-     * @return The actual amount of BNB transferred
-     */
-    function doTransferIn(address from, uint amount) internal returns (uint) {
-        // Sanity checks
-        require(msg.sender == from, "sender mismatch");
-        require(msg.value == amount, "value mismatch");
-        return amount;
-    }
+    emit ReservesReduced(admin, reduceAmount, totalReservesNew);
 
-    function doTransferOut(address payable to, uint amount) internal {
-        /* Send the BNB, with minimal gas and revert on failure */
-        to.transfer(amount);
-    }
+    return uint(Error.NO_ERROR);
+  }
 
-    /**
-     * @notice Gets balance of this contract in terms of BNB, before this message
-     * @dev This excludes the value of the current message, if any
-     * @return The quantity of BNB owned by this contract
-     */
-    function getCashPrior() internal view returns (uint) {
-        (MathError err, uint startingBalance) = subUInt(address(this).balance, msg.value);
-        require(err == MathError.NO_ERROR, "cash prior math error");
-        return startingBalance;
+  /**
+   * @notice Accrues interest and reduces reserves by transferring to admin
+   * @param reduceAmount Amount of reduction to reserves
+   * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).
+   */
+  // @custom:event Emits ReservesReduced event
+  function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {
+    uint error = accrueInterest();
+    if (error != uint(Error.NO_ERROR)) {
+      // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.
+      return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);
     }
-
-    function requireNoError(uint errCode, string memory message) internal pure {
-        if (errCode == uint(Error.NO_ERROR)) {
-            return;
-        }
-
-        bytes memory fullMessage = new bytes(bytes(message).length + 5);
-        uint i;
-
-        for (i = 0; i < bytes(message).length; i++) {
-            fullMessage[i] = bytes(message)[i];
-        }
-
-        fullMessage[i + 0] = bytes1(uint8(32));
-        fullMessage[i + 1] = bytes1(uint8(40));
-        fullMessage[i + 2] = bytes1(uint8(48 + (errCode / 10)));
-        fullMessage[i + 3] = bytes1(uint8(48 + (errCode % 10)));
-        fullMessage[i + 4] = bytes1(uint8(41));
-
-        require(errCode == uint(Error.NO_ERROR), string(fullMessage));
+    // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.
+    return _reduceReservesFresh(reduceAmount);
+  }
+
+  /**
+   * @notice Applies accrued interest to total borrows and reserves
+   * @dev This calculates interest accrued from the last checkpointed block
+   *   up to the current block and writes new checkpoint to storage.
+   */
+  // @custom:event Emits AccrueInterest event
+  function accrueInterest() public returns (uint) {
+    /* Remember the initial block number */
+    uint currentBlockNumber = getBlockNumber();
+    uint accrualBlockNumberPrior = accrualBlockNumber;
+
+    /* Short-circuit accumulating 0 interest */
+    if (accrualBlockNumberPrior == currentBlockNumber) {
+      return uint(Error.NO_ERROR);
     }
 
-    /**
-     * @dev Function to simply retrieve block number
-     *  This exists mainly for inheriting test contracts to stub this result.
+    /* Read the previous values out of storage */
+    uint cashPrior = getCashPrior();
+    uint borrowsPrior = totalBorrows;
+    uint reservesPrior = totalReserves;
+    uint borrowIndexPrior = borrowIndex;
+
+    /* Calculate the current borrow interest rate */
+    uint borrowRateMantissa = interestRateModel.getBorrowRate(
+      cashPrior,
+      borrowsPrior,
+      reservesPrior
+    );
+    require(borrowRateMantissa <= borrowRateMaxMantissa, 'borrow rate is absurdly high');
+
+    /* Calculate the number of blocks elapsed since the last accrual */
+    (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);
+    require(mathErr == MathError.NO_ERROR, 'could not calculate block delta');
+
+    /*
+     * Calculate the interest accumulated into borrows and reserves and the new index:
+     *  simpleInterestFactor = borrowRate * blockDelta
+     *  interestAccumulated = simpleInterestFactor * totalBorrows
+     *  totalBorrowsNew = interestAccumulated + totalBorrows
+     *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves
+     *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex
      */
-    function getBlockNumber() internal view returns (uint) {
-        return block.number;
-    }
-
-    /**
-     * @notice Reduces reserves by transferring to admin
-     * @dev Requires fresh interest accrual
-     * @param reduceAmount Amount of reduction to reserves
-     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).
-     */
-    function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {
-        // totalReserves - reduceAmount
-        uint totalReservesNew;
-
-        // Check caller is admin
-        if (msg.sender != admin) {
-            return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);
-        }
-
-        // We fail gracefully unless market's block number equals current block number
-        if (accrualBlockNumber != getBlockNumber()) {
-            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);
-        }
-
-        // Fail gracefully if protocol has insufficient underlying cash
-        if (getCashPrior() < reduceAmount) {
-            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);
-        }
 
-        // Check reduceAmount ≤ reserves[n] (totalReserves)
-        if (reduceAmount > totalReserves) {
-            return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);
-        }
-
-        /////////////////////////
-        // EFFECTS & INTERACTIONS
-        // (No safe failures beyond this point)
-
-        totalReservesNew = totalReserves - reduceAmount;
-
-        // Store reserves[n+1] = reserves[n] - reduceAmount
-        totalReserves = totalReservesNew;
-
-        // // doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.
-        doTransferOut(admin, reduceAmount);
+    Exp memory simpleInterestFactor;
+    uint interestAccumulated;
+    uint totalBorrowsNew;
+    uint totalReservesNew;
+    uint borrowIndexNew;
+
+    (mathErr, simpleInterestFactor) = mulScalar(Exp({ mantissa: borrowRateMantissa }), blockDelta);
+    if (mathErr != MathError.NO_ERROR) {
+      return
+        failOpaque(
+          Error.MATH_ERROR,
+          FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED,
+          uint(mathErr)
+        );
+    }
 
-        emit ReservesReduced(admin, reduceAmount, totalReservesNew);
+    (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);
+    if (mathErr != MathError.NO_ERROR) {
+      return
+        failOpaque(
+          Error.MATH_ERROR,
+          FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED,
+          uint(mathErr)
+        );
+    }
 
-        return uint(Error.NO_ERROR);
+    (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);
+    if (mathErr != MathError.NO_ERROR) {
+      return
+        failOpaque(
+          Error.MATH_ERROR,
+          FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED,
+          uint(mathErr)
+        );
     }
 
-    /**
-     * @notice Accrues interest and reduces reserves by transferring to admin
-     * @param reduceAmount Amount of reduction to reserves
-     * @return uint Returns 0 on success, otherwise returns a failure code (see ErrorReporter.sol for details).
-     */
-    // @custom:event Emits ReservesReduced event
-    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {
-        uint error = accrueInterest();
-        if (error != uint(Error.NO_ERROR)) {
-            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.
-            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);
-        }
-        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.
-        return _reduceReservesFresh(reduceAmount);
+    (mathErr, totalReservesNew) = mulScalarTruncateAddUInt(
+      Exp({ mantissa: reserveFactorMantissa }),
+      interestAccumulated,
+      reservesPrior
+    );
+    if (mathErr != MathError.NO_ERROR) {
+      return
+        failOpaque(
+          Error.MATH_ERROR,
+          FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED,
+          uint(mathErr)
+        );
     }
 
-    /**
-     * @notice Applies accrued interest to total borrows and reserves
-     * @dev This calculates interest accrued from the last checkpointed block
-     *   up to the current block and writes new checkpoint to storage.
-     */
-    // @custom:event Emits AccrueInterest event
-    function accrueInterest() public returns (uint) {
-        /* Remember the initial block number */
-        uint currentBlockNumber = getBlockNumber();
-        uint accrualBlockNumberPrior = accrualBlockNumber;
-
-        /* Short-circuit accumulating 0 interest */
-        if (accrualBlockNumberPrior == currentBlockNumber) {
-            return uint(Error.NO_ERROR);
-        }
-
-        /* Read the previous values out of storage */
-        uint cashPrior = getCashPrior();
-        uint borrowsPrior = totalBorrows;
-        uint reservesPrior = totalReserves;
-        uint borrowIndexPrior = borrowIndex;
-
-        /* Calculate the current borrow interest rate */
-        uint borrowRateMantissa = interestRateModel.getBorrowRate(cashPrior, borrowsPrior, reservesPrior);
-        require(borrowRateMantissa <= borrowRateMaxMantissa, "borrow rate is absurdly high");
-
-        /* Calculate the number of blocks elapsed since the last accrual */
-        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);
-        require(mathErr == MathError.NO_ERROR, "could not calculate block delta");
-
-        /*
-         * Calculate the interest accumulated into borrows and reserves and the new index:
-         *  simpleInterestFactor = borrowRate * blockDelta
-         *  interestAccumulated = simpleInterestFactor * totalBorrows
-         *  totalBorrowsNew = interestAccumulated + totalBorrows
-         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves
-         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex
-         */
-
-        Exp memory simpleInterestFactor;
-        uint interestAccumulated;
-        uint totalBorrowsNew;
-        uint totalReservesNew;
-        uint borrowIndexNew;
-
-        (mathErr, simpleInterestFactor) = mulScalar(Exp({ mantissa: borrowRateMantissa }), blockDelta);
-        if (mathErr != MathError.NO_ERROR) {
-            return
-                failOpaque(
-                    Error.MATH_ERROR,
-                    FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED,
-                    uint(mathErr)
-                );
-        }
-
-        (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);
-        if (mathErr != MathError.NO_ERROR) {
-            return
-                failOpaque(
-                    Error.MATH_ERROR,
-                    FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED,
-                    uint(mathErr)
-                );
-        }
-
-        (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);
-        if (mathErr != MathError.NO_ERROR) {
-            return
-                failOpaque(
-                    Error.MATH_ERROR,
-                    FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED,
-                    uint(mathErr)
-                );
-        }
-
-        (mathErr, totalReservesNew) = mulScalarTruncateAddUInt(
-            Exp({ mantissa: reserveFactorMantissa }),
-            interestAccumulated,
-            reservesPrior
+    (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(
+      simpleInterestFactor,
+      borrowIndexPrior,
+      borrowIndexPrior
+    );
+    if (mathErr != MathError.NO_ERROR) {
+      return
+        failOpaque(
+          Error.MATH_ERROR,
+          FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED,
+          uint(mathErr)
         );
-        if (mathErr != MathError.NO_ERROR) {
-            return
-                failOpaque(
-                    Error.MATH_ERROR,
-                    FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED,
-                    uint(mathErr)
-                );
-        }
-
-        (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);
-        if (mathErr != MathError.NO_ERROR) {
-            return
-                failOpaque(
-                    Error.MATH_ERROR,
-                    FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED,
-                    uint(mathErr)
-                );
-        }
-
-        /////////////////////////
-        // EFFECTS & INTERACTIONS
-        // (No safe failures beyond this point)
-
-        /* We write the previously calculated values into storage */
-        accrualBlockNumber = currentBlockNumber;
-        borrowIndex = borrowIndexNew;
-        totalBorrows = totalBorrowsNew;
-        totalReserves = totalReservesNew;
-
-        /* We emit an AccrueInterest event */
-        emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);
-
-        return uint(Error.NO_ERROR);
     }
+
+    /////////////////////////
+    // EFFECTS & INTERACTIONS
+    // (No safe failures beyond this point)
+
+    /* We write the previously calculated values into storage */
+    accrualBlockNumber = currentBlockNumber;
+    borrowIndex = borrowIndexNew;
+    totalBorrows = totalBorrowsNew;
+    totalReserves = totalReservesNew;
+
+    /* We emit an AccrueInterest event */
+    emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);
+
+    return uint(Error.NO_ERROR);
+  }
 }
diff --git a/node_modules/@venusprotocol/venus-protocol/contracts/test/VBep20MockDelegate.sol b/node_modules/@venusprotocol/venus-protocol/contracts/test/VBep20MockDelegate.sol
index fe9520f..13226a8 100644
--- a/node_modules/@venusprotocol/venus-protocol/contracts/test/VBep20MockDelegate.sol
+++ b/node_modules/@venusprotocol/venus-protocol/contracts/test/VBep20MockDelegate.sol
@@ -1,6 +1,6 @@
 pragma solidity ^0.5.16;
 
-import "../Tokens/VTokens/VToken.sol";
+import {CorePoolVToken as VToken } from "../Tokens/VTokens/VToken.sol";
 
 /**
  * @title Venus's VBep20 Contract
